# 5장. 서비스 추상화
### 필드 추가

- 상수 값이 필요하다면 enum을 적극 활용하자
    - 범위 밖의 값을 넣을 위험이 없다.
    - DB에는 int 값을, 코드에서는 오브젝트를 안전하게 사용할 수 있다.
    

### 사용자 수정 기능

JDBC 개발에서 기본 작업을 제외하고 가장 많은 실수가 일어나는 곳 ? → SQL 문장 !

- JdbcTemplate의 update()가 돌려주는 리턴 값을 확인한다.
    - 영향 받은 row의 개수
- 테스트를 보완한다.
    - 원하는 사용자 외의 정보는 변경되지 않았는지

### 트랜잭션

더 이상 나눌 수 없는 단위 작업

- 중간에 예외가 발생하면 원래대로 돌려놔야 한다.

### 트랜잭션 경계 설정

**모든 트랜잭션은 시작 지점과 끝 지점이 있다 !**

- 시작 지점은 하나
- 끝나는 지점은 둘
    - 롤백, 커밋

**🤔 비즈니스 로직 내 트랜잭션 경계 설정의 문제점**

- JdbcTemplate 활용 불가
    - 리소스의 깔끔한 처리 불가
- DAO와 비즈니스 로직 메서드에 Connection 파라미터 전달 필요
    - 멀티스레드 환경에서 서로 덮어쓰는 상황 발생 가능
    - 데이터 액세스 기술에 독립적일 수 없음 (DAO)

### 트랜잭션 동기화

**컨셉**

- Connection 오브젝트를 보관해둔다.
- 트랜잭션이 필요할 때 꺼내다 쓴다.

TransactionSynchronizationManager : 트랜잭션 동기화 저장소

- 작업 스레드마다 독립적으로 Connection 오브젝트를 관리
- 멀티 스레드 환경에서도 충돌하지 않음
- 문제점: 데이터 접근 기술에 아직 의존적임

### 트랜잭션 추상화

**컨셉**

- 스프링은 데이터 접근 기술에 독립적인 트랜잭션을 사용할 수 있음
- 형태만 다르고 기능은 같기 때문에 추상화가 가능함

[PlatformTransactionManager](https://docs.spring.io/spring-framework/reference/data-access/transaction/strategies.html) : JPA, JDBC 등의 트랜잭션을 추상화

- 기술에 독립적
- 트랜잭션 경계 설정 가능
- 전략 패턴

### 서비스 추상화

스프링의 DI로 결합도가 낮은 구조를 만들 수 있다.

- 코드의 기능적인 관심에 따라 분리
- 서로 불필요한 영향을 주지 않음
- 독자적으로 확장 가능

→ 앗 ! 단일 책임 원칙 뚝딱 !

### 메일 서비스 추상화

1. JavaMail API를 사용하는 메서드 추가
2. 메일 서버로 요청이 전달되는지를 테스트
3. 테스트를 위한 JavaMailSender 인터페이스 이용 (스프링 제공)
    - 트랜잭션 개념도 적용하자

**테스트 대역**

- 테스트 스텁
- 목 오브젝트
