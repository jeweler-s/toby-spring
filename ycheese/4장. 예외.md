# 4장. 예외
### 👎 나쁜 습관

- try-catch로 잡아서 아무것도 하지 않으면 안된다.
- 출력만 하는 것도 안된다.
- `throws Exception`도 안된다.
    - 사용하는 입장에서도 정보를 얻을 수 없어서 throws하게 됨

### 📍 핵심 원칙

- 모든 예외는 적절하게 복구될 것
- 복구되지 못한다면 작업을 중단시키고 분명하게 통보할 것

### 🔍 예외

- **Error**
    - `java.lang.Error`의 서브 클래스들 → 시스템이 비정상인 경우
    - 코드에서 처리할 수 있는 방법이 없다.
    - 결론: 신경쓰지 말 것
- Exception
    - `java.lang.Exception`의 서브 클래스들
    - 체크 예외와 언체크 예외로 나뉨

### 🔍 언체크 예외 vs 체크 예외

- **언체크 예외**
    - RuntimeException 클래스를 상속한 것
    - 주로 프로그램에 오류가 있을 때 발생되도록 의도됨
- **체크 예외**
    - RuntimeException 클래스를 상속하지 않은 것
    - **반드시 예외 처리 코드를 작성**해야 함

### 🔍 예외 처리 방법

- **예외 복구**
    - 문제를 해결해서 정상으로 돌려놓자 !
    - 재시도 등 어떤 식으로든 복구 가능성이 있는 경우 사용
- **예외 회피**
    - `throws`
    - 콜백 오브젝트의 메소드인 경우 템플릿 레벨에서 처리하도록 하는 것
    - `throws Exception` 밭이 되지 않도록 유의할 것
- **예외 전환**
    - 적절한 예외로 전환해서 던지기
        - 그대로 던지는 게 적절한 의미 부여가 안되는 경우 → 명시적인 예외로 전환
        - 복구 가능한 예외가 아닌 경우 → 발생할 수 있는 예외들을 하나로 포장
        - 중첩 예외(Throwable cause) 추천 !

### 🔍 예외 처리 전략

- **그냥 런타임 예외를 던지자.**
    - 항상 복구할 수 있는 게 아니라면? 포장하자
- **런타임 예외를 던지면 문서화하자.**
    - 어떤 예외가 던져지고
    - 왜 예외가 발생하고
    - 어떻게 활용할 수 있는가?
- **코드로 리턴하자.**
    - 예외 상태에 대한 특별한 값을 리턴
    - 경우에 따라 작업이 달라져야 하는 경우
    - 관리 포인트 증가

### 🔍 JDBC의 한계 ?

- 비표준 SQL
    - DB 변경 가능성을 고려한다면 … 👎
- 에러 정보 호환성
    - 예외 원인이 너무 많다 …
    - DBMS가 바뀌면 코드도 달라진다.

**→ 스프링은 DB 독립적으로 적용할 수 있는 `DataAccessException`을 제공**

### ⚠️ DataAccessException 활용 주의사항

- 근본적인 한계로 완벽하지 못하다.
    - 학습 테스트를 적극 활용할 것
- 기술 종류와 상관없이 동일한 예외를 얻으려면 직접 예외를 정의해서 전환할 것
