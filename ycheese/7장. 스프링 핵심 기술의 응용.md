# 7장. 스프링 핵심 기술의 응용

> 스프링이 가장 가치를 두고 적극적으로 활용하려고 하는 것은 결국 자바가 기반을 두고 있는 **객체지향 기술**이다.
> 

# SQL, DAO에서 분리하기

## 1. XML 설정

- 설정을 이용해 빈에 값을 주입
    - SQL을 설정 파일에 프로퍼티 값으로 정의해서 DAO에 주입
- 👎 단점 : 새로운 SQL이 필요할 때마다 프로퍼티, 변수, 메소드 추가 필요

## 2. SQL 맵 프로퍼티

- Map을 이용하여 키 값을 이용해 SQL 문장 가져오기
- xml에 <map> 태그를 사용해서 정의
- 👎 단점 : 키 값 등에 오타가 있어도 런타임에서만 확인할 수 있음

## 3. SQL 제공 서비스

- 인터페이스 - 구현체 클래스를 만들고 Map 프로퍼티를 추가
- DAO는 SQL을 어디서 가져오는지 신경쓰지 않는다.

# 인터페이스 분리와 자기 참조 빈

## 🌱 빈 초기화

### @PostConstruct

- 스프링에서 빈 오브젝트의 초기화 메소드를 지정할 때 사용
- 빈 오브젝트 생성 → DI → @PostConstruct가 붙은 메소드 자동 실행
- **생성자와 다른 점?**
    - 프로퍼티까지 모두 준비된 후에 실행됨

## 🎬 자기 참조 빈으로 시작하기

### 다중 인터페이스 구현과 간접 참조

- 세분화된 책임을 정의한 인터페이스 구현
- 같은 클래스 코드지만 책임이 다른 코드는 인터페이스를 통해 간접 접근

### 자기 참조 빈 설정

- ref 항목에 자기 자신을 넣는다.

## 👯 디폴트 의존관계

외부에서 DI 받지 않는 경우 자동 적용되는 의존관계

- 디폴트로 적용하고 싶은 의존 오브젝트를 생성자에 추가
- 빈 설정이 없어짐

# 인터페이스 상속으로 안전하게 확장하기

## 📣 DI와 확장

### DI를 의식하는 설계하기

- 커다란 오브젝트 하나만 존재하면 안됨
- 의존 관계를 가지고 협력해서 일하는 오브젝트가 필요함
    - 적절한 책임에 따른 오브젝트 분리
    - 의존 오브젝트는 자유롭게 확장될 수 있음
- 미래를 프로그래밍하자 !

### 인터페이스 프로그래밍

- 두 개의 오브젝트가 인터페이스를 통한 느슨한 결합을 맺는 것이 DI다운 DI
    - 다형성++
    - 인터페이스 분리 원칙
- 기존 인터페이스를 상속하여 확장할 수 있음

# DI로 다양하게 구현하기

## ConcurrentHashMap

- 동기화된 해시 데이터 조작에 최적화된 자료구조
    - 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 아예 사용하지 않음
    - 안전하고 성능이 보장되는 동기화된 HashMap

## 내장형 데이터베이스

- 저장되는 데이터 양이 많아지고 잦은 조회/변경이 일어나는 경우 추천
- 애플리케이션에 내장되어 애플리케이션과 함께 시작/종료되는 데이터베이스
- 메모리에 저장되어 I/O 부하가 적고 성능이 좋음

## 트랜잭션 적용

### EmbeddedSqlRegistry

- 내장형 DB 사용
    - 조회가 빈번해도 데이터 깨짐 없이 안전한 SQL 수정 보장
- 하나 이상의 SQL을 수정해야 하는 경우 문제 발생 가능
    - **왜 여러 SQL을 동시에 수정하는가 ?**
        - SQL이 서로 관련있기 때문
        - 여러 SQL 수정 작업은 반드시 트랜잭션 안에서 일어나야 함

### 내장형 DB의 트랜잭션 격리 수준

- HSQL 1.8 이하 : READ_UNCOMMITTED
    - 한 트랜잭션이 종료되기 전의 작업 내용을 다른 트랜잭션이 읽을 수 있음
- HSQL 1.9 이상, H2, Derby : READ_COMMITTED
    - 낮은 격리 수준의 위험성을 피하기 위해 권장

# 스프링 3.1의 DI

## 자바의 변화

### ☝🏻 애노테이션의 메타정보 활용

- 리플렉션 API
    - 자바 코드나 컴포넌트를 작성하는 데 사용되는 툴을 개발할 때 이용하도록 만들어짐
    - 자바 코드의 메타정보를 데이터로 활용하는 스타일의 프로그래밍 방식에 활용 (애노테이션 Since Java5)
- 애노테이션
    - 옵션에 따라 컴파일된 클래스에 존재하거나 애플리케이션이 동작할 때 메모리에 로딩
    - 자바 코드가 실행되는 데 직접 참여하지 못함
    - 상속/오버라이딩 불가
    
    **왜 쓰는가?**
    
    - 아래 3가지로 구성하는 방식에 잘 어울리기 때문
        1. 애플리케이션의 핵심 로직을 담은 자바 코드
        2. IoC 방식의 프레임워크
        3. 프레임워크가 참조하는 메타정보
    - xml의 단점 극복 !!!

### ✌🏻 정책과 관례를 이용한 프로그래밍

- 코드 없이 미리 약속한 규칙에 따라 프로그램이 동작하게 할 수 있음
- 간결한 코드에 많은 내용을 담을 수 있음

## 빈 스캐닝과 자동 와이어링

### @Autowired

- 스프링 컨테이너가 생성한 빈을 클래스의 멤버 필드로 주입받기 위해 사용
- 컨테이너가 자동으로 주입할 빈을 결정하기 어려운 경우 직접 프로퍼티에 주입할 대상을 지정하는 방법을 병행 가능

### @Component

- 클래스에 부여됨
- 빈 스캐너를 통해 자동으로 빈으로 등록됨
- @ComponentScan의 basePackages 엘리먼트는 @Component 클래스를 스캔할 기준 패키지를 지정할 때 사용

### @Import

- 테스트에 사용할 빈 정보를 별도의 클래스로 분리하자
- AppContext에 성격이 같은 빈 설정정보를 남기자
    - 다른 성격의 서비스가 포함되어 있다면 @Configuration 클래스를 하나 더 만든다.
- AppContext 클래스 레벨에 @Import로 설정 클래스를 적용한다.

### @Profile, @ActiveProfile

- 환경에 따라서 빈 설정정보가 달라져야 하는 경우 스프링은 간단히 설정정보를 구성할 수 있는 방법을 제공한다.
- @Profile은 설정 클래스 단위로 지정한다.
- @ActiveProfiles는 스프링 컨테이너를 실행할 때 추가로 지정하는 속성을 지정한다.
