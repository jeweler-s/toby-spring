# 2장. 테스트
### 🔮 이 장의 명언

- 스프링으로 개발을 하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다.
- 작은 버그 하나의 추억이라는 건, 사실 진작에 충분한 테스트를 했었다면 쉽게 찾아냈을 것을 미루고 미루다 결국 커다란 삽질로 만들어버린 어리석은 기억일 뿐이다.
- 일반적으로 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다. 그 반대도 마찬가지다.

### 🙋🏻‍♀️ 스프링이 개발자에게 제공하는 가장 중요한 가치는?

- **객체지향**
    - IoC와 DI를 통해 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발
- **테스트**
    - 애플리케이션의 계속되는 변화에 유연하게 대처할 수 있는 자신감

### 💁🏻‍♀️ 테스트는 이렇게

- 작은 단위의 테스트
    - (= **단위 테스트**)
    - 관심사의 분리를 테스트에도 적용하자 !
    - 빠른 확인이 가능
- 자동 수행 테스트
    - 자주 테스트해도 부담이 없다 !
- 지속적인 개선과 점진적인 개발을 위한 테스트
    - 중간에 실수해도 테스트를 통해 확인 가능
- 동일한 결과 보장
    - 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 결과를 얻을 것
- 포괄적인 테스트
    - 성의 없는 테스트를 만들면 문제가 있는 코드도 테스트가 성공함
    - 충분한 검증이 없는 테스트는 없는 것보다 나쁘다
        
        → **네거티브 테스트 먼저 작성**
        
- 순서에 영향받지 않는 테스트
    - 어느 테스트가 먼저 실행될 지 알 수 없다.
    - 테스트 결과가 순서에 영향을 받는다면 잘못 만든 것이다.

### 💡 JUnit

= 테스트 프레임워크

- `main()` 메소드 필요 X
- 오브젝트를 만들어 실행시키는 코드 필요 X

**필요 조건**

- public 메소드 선언
- `@Test` 어노테이션
- 리턴 타입 void
- 파라미터가 없는 메소드

**특징**

- 예외가 발생하거나 단언에서 실패하지 않고 테스트 메소드 실행이 완료되면 테스트 성공으로 인식
- 단언에서 실패 시, 일반 예외(Exception) 발생 시 모두 테스트 실패로 간주

### 🤔 JUnit의 테스트 메소드는 왜 public 이어야 하는가?

- JUnit은 리플렉션 api를 사용
    - 과거 자바의 리플렉션 api는 public 메소드만 접근 가능했음.
    - JDK1.2 부터 리플렉션에서 public 외 모든 접근 레벨을 허용하기 시작했으나 전통을 유지해서 public 메소드만 허용중
    
    [관련 링크](https://groups.google.com/g/ksug/c/xpJpy8SCrEE)
    

### 💡 TDD

- 테스트 코드는 잘 작성된 **기능 정의서**처럼 보인다.
- 테스트 코드를 만들고, 테스트가 성공하게끔 코드를 작성하고, 리팩토링하는 과정을 반복
- 테스트를 빼먹지 않고 꼼꼼하게 만들 수 있다.
- 코드에 대한 피드백이 빠르다.

### 💡 **JUnit이 테스트를 수행하는 방식**

1. 테스트 클래스에서 @Test가 붙은 public void형의 파라미터가 없는 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 만든다.
3. @Before 메소드를 실행한다.
    - 픽스처(fixture): 테스트를 수행하는 데 필요한 정보나 오브젝트
    - 여러 테스트에서 반복적으로 사용되는 것을 생성해두기 좋다.
4. @Test 메소드를 호출하고 결과를 저장해둔다.
5. @After 메소드를 실행한다.
6. 나머지 테스트 메소드에 대해 2~5 번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

### 🤔 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는가?

- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실하게 보장하기 위해
- 인스턴스 변수를 부담없이 사용할 수 있게 하기 위해
    - 다음 테스트 메소드가 실행될 때 새로운 오브젝트가 만들어지니까 ~ 😎 (=초기화되니까)

### 스프링 테스트

- JUnit은 매번 테스트 클래스의 오브젝트를 새로 만든다.
- 애플리케이션 컨텍스트 관련 문제가 생긴다.
    - 빈이 많아질수록 생성 시간이 오래 걸린다.
    - 테스트 후 컨텍스트 안 빈을 초기화하지 않으면 다음 테스트에서 새 애플리케이션 컨텍스트를 만들 때 문제가 생길 수 있다.
- **애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트를 만들 수 있다.**
- 테스트에서 사용할 애플리케이션 컨텍스트를 하나 만들고 공유한다.

```java
@ExtendWith(SpringExtension.class) // (JUnit5)
@ContextConfiguration(locations="/resources/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    ApplicationContext applicationContext;
    UserDao userDao;

    @BeforeEach
    public void setUp() {
        System.out.println("applicationContext = " + applicationContext);
        System.out.println("this = " + this);
        this.userDao = this.applicationContext.getBean("userDao", UserDao.class);
```

1. `@ExtendWith` : JUnit5에서 테스트 클래스를 확장할 때 쓰이는 애노테이션
2. `@ContextConfiguration` : locations 속성으로 ApplicationContext에 사용될 xml 파일 위치 지정
3. `@Autowired` : 테스트용 `ApplicationContext` 내부에 있는 정의된 타입의 빈

### 👯 테스트 간 컨텍스트 공유

스프링의 JUnit 확장 기능은 테스트 실행 전 딱 한 번 애플리케이션 컨텍스트를 만들고 테스트 오브젝트가 만들어질 때마다 테스트 오브젝트의 특정 필드에 주입해준다. (일종의 DI)

- 🤔 클래스 간 공유는 어떻게?
    - 테스트 수행 중 단 한 개의 애플리케이션 컨텍스트가 만들어진다.
    - 두 테스트 클래스가 한 애플리케이션 컨텍스트를 공유한다.
    

### 💡 DI

- 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문에 인터페이스를 사용하자.
- DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 한다.
- DI를 이용한 테스트 방법 선택
    - 스프링 컨테이너 없이 테스트할 수 있는 방법을 최우선으로 고려
    - 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트할 경우 스프링의 설정을 이용한 DI 방식의 테스트를 이용 권장
        - 애플리케이션 컨텍스트 사용 시 테스트 전용 설정 파일을 만들 것
    - 테스트 설정이 분리되어도 예외적 의존 관계를 구성해야 하는 경우 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용
        - `@DirtiesContext`
            - 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알린다.
            - 이 어노테이션이 붙은 테스트 클래스는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
            - 메소드 레벨로도 적용 가능하다.

### 💡 학습 테스트

- 테스트 코드를 만드는 과정을 통해 API의 사용 방법을 익힌다.
- 내가 가진 기술에 대한 지식을 검증한다.

### 💡버그 테스트

코드에 오류가 있을 때 그 오류를 가장 잘 드러내주는 테스트

- 테스트의 완성도를 높인다.
- 버그의 내용을 명확하게 분석한다.
- 기술적 문제를 해결하는 데 기여한다.
- **경계 값 분석**
    - 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용
    - 경계 값을 이용해 테스트한다.

### 👍🏻 결론

- 테스트는 자동화하여 빠르게 실행할 수 있어야 한다.
- JUnit 테스트 프레임워크로 테스트 자동화가 가능하다.
- 테스트 결과는 일관성이 있어야 한다.
- 테스트는 환경이나 순서에 영향을 받으면 안된다.
- 충분한 검증이 없는 테스트는 없는 것 보다 나쁘다. (네거티브 테스트)
- 코드 작성 - 테스트 수행의 간격을 좁히자.
- 테스트하기 쉬운 코드가 좋은 코드다.
- TDD 추천 ~
- 테스트 코드도 리팩토링이 필요하다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능이 향상된다.
