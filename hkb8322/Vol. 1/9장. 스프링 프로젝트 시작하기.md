# 9.1 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

## 애플리케이션 서버

스프링으로 만든 애플리케이션을 서버 환경에 배포하려면 JavaEE 서버 필요

1. `경량급 WAS/서블릿 컨테이너` : 톰캣, 제티 등으로도 대부분의 기능 충분히 사용 가능
2. `WAS` : 고도의 안정성이나 고성능 시스템에서 리소스 관리 등 필요 시 사용

## 스프링 애플리케이션의 배포 단위

1. `독립 웹 모듈` : `war` 파일
2. `엔터프라이즈 애플리케이션` : `ear` 파일
3. `백그라운드 서비스 모듈` : `rar` 패키징 방식

# 9.2 개발도구와 환경

## SpringSource Tool Suite (STS)

### SpringIDE 플러그인

- 빈 클래스 이름 자동 완성
- 빈 설정 오류검증 기능
- 프로젝트 생성, 설정파일 생성, 빈 등록 위저드
- 빈 의존관계 그래프
- AOP 적용 대상 표시

### STS 플러그인

- 스프링 애플리케이션의 서버 배치와 같은 추가 기능 제공

### 기타 플러그인

- M2Eclipse
- AJDT
- VMCI
- 이클립스 표준 플러그인

## 라이브러리 관리의 어려움

- 필요한 프레임워크 모듈과 라이브러리 파일을 선택하여 프로젝트의 빌드 패스에 넣어주는 게 가장 어려움
- 라이브러리 조합을 만들다 보면 의존관계 속에서 라이브러리가 충돌하기도 함

## 라이브러리 선정

- 불필요한 라이브러리는 처음부터 추가하지 않아야 함
- 사용 기술이나 기능이 변경되어 불필요해진 라이브러리는 바로 제거할 수 있도록 노력 필요

## 빌드 툴과 라이브러리 관리

- `ANT` : 이클립스에 내장되어 있던 구 자바 표준 빌드 툴
    - 절차적인 스크립트 구조와 유사
- `Maven` : 종합 프로젝트 관리 툴
    - POM이라는 프로젝트 모델 정보 이용
    - 애플리케이션이 필요로 하는 의존 라이브러리를 선언하면 원격 서버에서 자동으로 다운로드
    - 전이적 의존 라이브러리 추적 기능 (동작에 필요한 다른 라이브러리까지 같이 다운로드)

## 스프링 모듈의 두 가지 이름과 리포지토리

아래 두 파일은 동일한 파일

### Maven 명명규칙

> spring-core-3.0.7.RELEASE.jar
> 
- 그룹 아이디와 아티팩트 아이디, 버전으로 라이브러리 정의
- 아티팩트 아이디와 버전을 조합하여 파일 이름으로 사용

### OSGi 명명규칙

> org.springframework.core-3.0.7.RELEASE.jar
> 
- OSGi 플랫폼에서 사용되지 않아도 OSGi 스타일의 모듈 이름을 사용하도록 권장
- Maven 표준 리포지토리 대신 스프링소스가 제공하는 번들 리포지토리 사용 필요

# 9.3 애플리케이션 아키텍처

## 계층형 아키텍처

- 책임과 성격이 다른 것을 크게 그룹을 만들어 분리해두는 아키텍처
- 3계층 애플리케이션, 멀티 티어 아키텍처와 동의어

### 계층 구조

**1) 데이터 액세스 계층 (=DAO 계층, EIS 계층)**

- DB 또는 레거시 시스템과 연동하는 인터페이스 역할을 하는 계층
- 사용 기술에 따라 추상화 수준에 따라 수직 계층 구조를 가질 수 있음
- 추상화 계층 구조를 따른다면 항상 추상 계층을 통해 접근하도록 코드 작성 필요
- 추상 계층 도입이 부담스러운 경우 유틸리티나 헬퍼 메소드 또는 오브젝트로 공통 기능을 분리하여 제공하는 방안도 사용 가능
(단, 가이드라인과 정책이 잘 갖춰진 상태에서 개발자에게 제공되어야 함)

**2) 서비스 계층 (= 매니저 계층, 비즈니스 로직 계층)**

- POJO로 객체지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 담음
- 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요 없음
- **서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안됨**
    - 추상화된 기반 서비스 인터페이스를 통해서만 접근 가능하도록 해야 함
- 애플리케이션에서 가장 중요한 자산인 도메인의 핵심 비즈니스 로직이 담긴 계층

**3) 프레젠테이션 계층 (= 웹 계층, UI 계층, MVC 계층)**

- 매우 다양한 기술과 프레임워크의 조합으로 구현되는 계층
- 전에는 클라이언트가 단순 UI에 불과했으나 점점 많은 프레젠테이션 로직이 클라이언트로 이동

### 설계 원칙

- 각 계층은 자신의 계층의 책임에만 충실해야 함
    - 데이터 액세스 계층에서 Entity, SQLException 리턴 ❌
    - 프레젠테이션 계층의 오브젝트를 서비스 계층으로 전달 ❌
- ⚠️ DI는 계층을 구분하지 않으므로 의존관계 생성 시 주의 필요

## 애플리케이션 정보 아키텍처

### 데이터 중심 아키텍처

- 애플리케이션에 존재하는 정보를 단순 데이터로 취급 **⇒ 데이터가 강한 결합을 만듦**
- 객체지향 기술을 사용하지 않은 애플리케이션과 다를 바가 없음
- 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향
- 기능을 세분화해 분리하고 재사용하지 않으므로 코드 다량 중복, **변경에 취약**
- DB(프로시저) 내 많은 로직을 보유하여 자바 코드는 단순 DB ↔ Web 연결 인터페이스로 전락

⇒ 상대적으로 애플리케이션 서버와 서버 내 오브젝트가 비용이 적어 애플리케이션 내 로직이 존재하는 것이 안정성, 검증 등 여러 방면에서 유리함

### 거대한 서비스 계층 방식

- 데이터 중심 아키텍처와 달리 주요 로직은 서비스 계층의 코드에서 처리
- 여전히 SQL 결과를 단순 오브젝트 또는 맵을 이용해 데이터를 주고 받음
- 결국 트랜잭션 단위로 거대한 메소드가 만들어지게 됨
- 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉬움
- 초기 개발 속도는 빠르지만 개발자에 따라 코드 스타일이 상이하여 다른 스타일의 코드 양산
- 계층별로 독립된 설계와 개발이 어려움

⇒ 결국 데이터 중심 아키텍처는 결합도 ↑, 응집도 ↓

## ⭐ 오브젝트 중심 아키텍처

- 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용
    - 도메인 모델은 DB 엔티티 구조와도 유사할 확률이 높음
- 도메인 오브젝트는 애플리케이션 어디에서도 사용될 수 있는 형식의 정보를 담고 있음

### 도메인 오브젝트 사용의 문제점

**문제점**

- 최적화된 SQL을 만들어 사용하는 경우에 비해 성능상 단점 존재
- 유관 객체를 도메인 오브젝트 내 포함할 경우 도메인 오브젝트만 별도로 조회하기 어려움

**해결 방법**

1. 지연된 로딩
2. 자주 사용되는 필드만 별도 오브젝트로 정의
3. ✅ **ORM 기술 사용**

⇒ ORM과 같은 오브젝트 중심 데이터 액세스 기술 사용 권장

## 오브젝트 활용 방안에 따른 분류

### 1️⃣ 빈약한 도메인 오브젝트 방식

- `빈약한 오브젝트` : 정보만 담겨 있고 기능이 없는 도메인 오브젝트
- 무조건 나쁜 방식은 아님, 상황에 따라 활용 가능
- 서비스 계층에 비즈니스 로직이 존재
- 거대 서비스 계층 방식의 하나
- SQL에 의존적인 데이터 방식보다 유연하고 간결하지만 재사용성 저하, 중복 발생
- 비즈니스 로직이 복잡하지 않다면 만들기 쉽고 3계층 구조의 특징을 살려 개발 가능

### 2️⃣ 풍성한 도메인 오브젝트 방식
- `풍성한/영리한 오브젝트` : `빈약한 오브젝트`의 단점 극복, 객체지향적인 특징 살림
- 비즈니스 로직이 서비스 계층에만 구현되어 있으면 해당 서비스를 DI 받아 사용해야 함
    - **정보를 담고 있는 오브젝트와 그 정보를 다루는 메소드가 분리되어 있기 때문**
- 특정 도메인 오브젝트에 종속되는 비즈니스 로직은 도메인 오브젝트에 포함시킴
- 서비스 계층이 필요가 없어진다? (❌)
    - 여러 도메인 조합하여 비즈니스 로직 구현하는 경우 등 여전히 필요
    - 도메인 오보젝트는 DAO 계층이나 기반 계층, 다른 서비스 계층에 접근 불가하므로 필요
    도메인 오브젝트는 빈이 아니므로 자동 DI 불가
- 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결함

## 도메인 계층 방식
- 도메인 계층의 역할과 비중을 극대화하기 위해 별도 계층으로 격상
- 도메인 종속적 비즈니스 로직은 서비스 계층이 아닌 도메인 계층 내 오브젝트에서 진행
- 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층 기능 직접 활용
    - AspectJ AOP 사용 시 생성자 시점을 조인 포인트로 사용 가능
    - 일반 오브젝트도 AOP 적용 가능
- 도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정
- 도메인 오브젝트는 생명주기가 짧고, 싱글톤이 될 수 없고 빈 등록 불가
    - 사용자별 요청에 대해 독립적인 상태 유지 필요
    - 상태 정보를 담고 있기 때문

### 서비스 계층의 역할

1. 도메인 오브젝트의 기능을 조합하여 복잡한 작업 진행
2. 도메인 계층을 거치지 않고 바로 데이터 액세스 계층으로부터 정보를 클라이언트에 제공 가능
3. 트랜잭션 경계를 설정하거나 기반 서비스 이용 작업에 사용

### 설계 시 고려 사항

- 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정 필요
    1. 모든 계층에서 도메인 오브젝트 사용
    2. 도메인 오브젝트는 도메인 계층에서만 사용

### DTO와 리포트 쿼리

- `DTO` : 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트
- `리포트 쿼리` : 분석/통계 결과를 생성하는 쿼리

## 스프링 애플리케이션을 위한 아키텍처 설계

- 계층 구조를 어떻게 나눌 것인지, 애플리케이션 정보를 어떻게 다룰 것인지 결정 필요

### 계층형 아키텍처

- 계층 통합 시 `서비스 계층 + 데이터 액세스 계층` > `프레젠테이션 계층 + 서비스 계층`
    - 후자는 스프링 AOP를 이용해 트랜잭션 경계를 설정하기 애매함
    - 전자를 사용하더라도 논리적으로 계층 경계를 분명하게 하는 게 좋음
- `SOFEA` : 프레젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드, 클라이언트에서 동작하며 서버에 존재하는 서비스 계층 또는 부분 프레젠테이션 계층과 통신하는 구조

**계층별 구조**

- `프렌젠테이션 계층` : Spring MVC를 이용
- `서비스 계층` : POJO로 구현하면서 트랜잭션 AOP를 적용
- `데이터 액세스 계층` : JDBC를 비롯해 스프링의 데이터 액세스 전략이 적용된 JPA, 하이버네이트 등을 활용

⇒ 처음엔 위와 같이 시작하면서 점차 계층의 통합과 분산 시도

### 정보 전송 아키텍처

- 빈약한 도메인 오브젝트 방식으로 시작
- 도메인 오브젝트를 계층 간 정보 전송을 위해 사용, 이를 각 계층 코드에서 사용
- 도메인 계층 도입 시 충분한 사전 학습과 검증 선행 필요

**계층별 구조**

- `프레젠테이션 계층`
    - 도메인 오브젝트를 직접 활용
    - MVC 아키텍처에서도 모델은 도메인 오브젝트를 그대로 사용
    - 사용자가 입력한 폼의 정보도 도메인 오브젝트로 변환해서 사용
- `서비스 계층`
    - 비즈니스 로직을 도메인 오브젝트를 사용해서 작성
- `데이터 액세스 계층`
    - 서비스 계층에서 요청을 받거나 결과를 돌려줄 때 도메인 오브젝트 형태를 유지

## 상태 관리와 빈 스코프

- 애플리케이션은 하나의 HTTP 요청의 범위를 넘어 유지해야 하는 상태 정보 존재
- 엔터프라이즈 애플리케이션에서는 특정 사용자가 독점하여 배타적으로 사용하지 않음
- 서버의 자원이 특정 사용자에게 일정하게 할당되지 않음 ⇒ 상태를 갖지 않음(Stateless)
- 상태 정보 저장 필요 시 파일 시스템, 데이터그리드, DB, HTTP 세션과 같은 서블릿 컨테이너가 제공하는 공간 활용 가능
- **스프링은 상태가 유지되지 않는 빈과 오브젝트를 사용할 것을 권장**
    - 웹의 생리에 잘 맞고 개발 용이함
- 스프링에서는 싱글톤 외 다른 스코프의 빈 사용 가능

## 서드파티 프레임워크, 라이브러리 적용

스프링이 지원하는 기술이란?

1. 해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다.
    - 빈으로 등록하여 사용 불가할 경우 스프링 빈으로 등록하기 위한 `팩토리 빈` 도입 필요
2. 스프링의 서비스 추상화가 적용되었다.
    - 일관된 방법으로 코드를 작성하도록 함
3. 스프링이 지지하는 프로그래밍 모델을 적용했다.
    - ex) 불필요하게 예외를 처리하는 코드를 방지하기 위해 런타임 위주 예외 사용
4. 템플릿/콜백 지원
    - 네트워크 접근이나 파일 I/O처럼 실패할 가능성이 있는 시도를 하는 기술이라면 적용 고려

스프링이 지원하지 않는다고 이전 방식대로 코드를 만들어 외부 기술을 사용하는 것은 부끄러운 일

스프링 프로그래밍 모델과 개발 철학을 따르는 일관된 코드를 작성하는 데에 많은 관심 필요
