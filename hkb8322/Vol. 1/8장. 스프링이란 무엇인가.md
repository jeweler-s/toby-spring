스프링은 단순히 IoC/DI를 편하게 적용하도록 하는 것을 넘어,

엔터프라이즈 애플리케이션 개발의 전 영역에 걸쳐 다양한 종류의 기술에 관여함

# 8.1 스프링의 정의

> 1️⃣자바 엔터프라이즈 개발을 편하게 해주는 2️⃣오픈소스 3️⃣경량급 4️⃣애플리케이션 프레임워크
> 

## 자바 엔터프라이즈 개발을 편하게

- 로우 레벨 기술에 많은 신경을 쓰지 않고 애플리케이션의 핵심인 비즈니스 로직을 효과적으로 구현하도록 함
    - EJB도 동일한 목표를 가졌지만 접근 방법이 잘못되어 복잡함을 야기했음

## 오픈소스

- 비교적 제약이 적고 사용이 매우 자유로운 아파치 라이선스 버전 2.0 사용
- 공개된 공간 안에서 투명한 방식으로 다양한 참여를 통해 개발되어 빠르고 유연한 개발 가능
    - 사용자들은 발견한 버그를 신고하거나 기능 개선 요구 가능
- 오픈소스 개발 모델은 지속적이고 안정적인 개발이 지속될지 불확실함
    - 하지만 스프링은 개발을 책임질 전문 기업을 만들어 운영

## 경량급

- 불필요하게 무겁지 않음
- 가볍고 단순한 환경에서도 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있음
- 코드에 불필요하게 등장하던 프레임워크와 서버 환경에 의존적인 부분을 제거함으로써 가벼움

## 애플리케이션 프레임워크

- 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크
- 단지 여러 계층의 다양한 기술을 모아뒀기 때문에 프레임워크라고 하는 것은 ❌
- **핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용**
    - 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌
    - 이로 인해 애플리케이션을 편리하게 개발해줌

# 8.2 스프링의 목적

스프링의 목적을 이해하고 목적을 이루는 도구로 활용해야만 제대로된 가치를 얻을 수 있음

## 엔터프라이즈 개발의 복잡함의 이유

1. 기술적인 제약조건과 요구사항의 증가
2. 핵심 기능인 비즈니스 로직의 복잡도의 증가

## 복잡함을 가중시키는 원인

- 애플리케이션 실패 원인
    - 비즈니스 로직의 복잡함
    - 기술적인 복잡함

⇒ 두 가지의 복잡함이 한 곳에 얽혀 있고 한 번에 다루려 하다 보니 복잡도가 증가함

## 실패한 해결책: EJB

- 기술적인 복잡함을 애플리케이션 핵심 로직에서 분리하는 데에 성공하긴 함
- 하지만 EJB 환경에서 동작하기 위해 특정 인터페이스를 구현하고,특정 클래스를 상속하고, 서버에 종속적인 서비스를 통해서만 접근하고 사용이 가능하게 만들었음
    - 이로 인해 다형성, 추가 상속 불가 등 객체지향의 장점도 활용하지 못하게 됨

⇒ EJB라는 환경과 스펙에 종속되는 코드로 만들게 함

⇒ 침투적인 기술 🗡️

## 비침투적인 방식을 통한 효과적인 해결책: 스프링

- 스프링이 애플리케이션 코드에 불필요하게 나타나지 않도록 하여 
기술적인 복잡함과 비즈니스 로직을 분리할 수 있었음

## 기술적 복잡함을 상대하는 전략

### **`서비스 추상화`**

- 일관성 없는 기술과 서버 환경의 변화에 대한 전략
- 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스 분리
- 환경과 세부 기술에 독립적인 접근 인터페이스 제공
- 템플릿/콜백 패턴은 반복적인 작업 흐름과 API 사용 코드를` 제거

### **`AOP`**

- 기술과 비즈니스 로직의 혼재로 발생하는 복잡함에 대한 전략
- 기술 관련 코드를 분리하여 별도의 모듈로 관리하게 해줌

## 애플리케이션 로직의 복잡함을 상대하는 전략

- 비즈니스 로직은 DB가 아니라 애플리케이션 내에서 처리
    - DB는 확장하기 어렵고 많은 비용이 드는 공유 자원임
- `자바` 라는 객체지향 기술 그 자체가 전략임
    - 스프링은 단지 객체지향 언어의 장점을 살리도록 도와줌

## ⭐ 핵심 도구: 객체지향과 DI

- 기계적인 방법으로 항상 사용하는 틀에 박힌 구조의 빈만 정의하고 나머지 코드는 DI를 정의하려 하지 않았다면 잘못 사용하고 있는 것
- 기술적인 복잡함을 해결하거나 두 개의 복잡함이 섞이지 않게 하기 위해 DI가 사용됨
- 비즈니스 로직 자체의 복잡함을 해결하려면 객체지향 설계 기법이 더 중요함

# 8.3 POJO 프로그래밍

(그림 8-1)

## POJO(Plain Old Java Object)

### 조건

- 특정 규약에 종속되지 않음 (=꼭 필요한 API 외에는 종속되지 않아야 함)
- 특정 환경에 종속되지 않음 (=환경에 독립적)
- 객체지향 원리에 충실해야 함

### 장점

- 특정한 기술과 환겨엥 종속되지 않아 깔끔한 코드 가능
- 자동화된 테스트에 매우 유리
- 객체지향적인 설계를 자유롭게 적용 가능

## POJO 프레임워크

(그림 8-2)

- POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크 (=스프링)

# 8.4 스프링의 기술

## 1️⃣ IoC/DI

- 유연한 확장을 위해 사용
- DI는 OCP와 연관되어 있음

### DI 활용 방법

1. `핵심 기능의 변경` : 의존 대상의 구현 변경
2. `핵심 기능의 동적인 변경` : 애플리케이션이 동작하는 중간에 의존 대상을 동적으로 변경
(다이내믹 라우팅 프록시나 프록시 오브젝트 기법 활용)
3. `부가 기능의 추가` : 핵심 기능 유지한 채 부가 기능 추가 (데코레이터 패턴) **⇒ 일반화하면 AOP**
4. `인터페이스의 변경` : 호환되지 않는 인터페이스 사용 시 어댑터 패턴 활용 가능
5. `프록시` : 프록시 패턴에 DI 활용 가능
6. `템플릿과 콜백` : 항상 고정된 작업 흐름과 변경되는 부분을 분리하여 간결함 유지 (OCP 준수)
7. `싱글톤과 오브젝트 스코프` : DI할 오브젝트의 생명주기(스코프) 제어
8. `테스트` : 목 오브젝트 주입 등 오브젝트 사이에 일어나는 일을 조작 가능하도록 하여 테스트 가능

## 2️⃣ AOP

- AOP와 OOP는 배타적인 개념이 아님
- AOP는 객체지향 기술의 한계와 단점을 극복하게 도와주는 보조적인 프로그래밍 기술
- POJO 프로그래밍을 지원하기 위한 핵심 기술

### 적용 기법

1. `다이내믹 프록시 사용` : 데코레이터 패턴 응용, 스프링의 기본적인 AOP 구현 방식
2. `언어의 확장 이용` : 강력한 고급 기능을 가진 AspectJ 활용 가능

### 적용 단계

하나의 모듈이 수많은 오브젝트에 보이지 않게 적용되어 매우 주의하여 사용 필요

1. 미리 준비된 AOP 이용 (ex. 트랜잭션, `@Configurable`)
    - `@Configurable` : 도메인 오브젝트에 DI를 자동 적용하는 AOP 기능
        - 도메인 오브젝트를 전용 계층에 두고 접근하는 아키텍처 방식 사용 시 필요
        - AspectJ를 이용한 AOP 필요

1. 전담팀을 통한 정책 AOP 적용
2. AOP의 자유로운 이용

## 3️⃣ PSA(Portable Service Abstraction)

- 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 함
- POJO 코드가 기술에 직접 노출되지 않을 뿐 특정 환경과 기술을 사용하지 않기 때문에 종속적이지 않다는 것은 아님
- 서비스 추상화를 위해서는 DI가 필요 **⇒ DI 응용 방법의 한 가지**
- 테스트가 어렵게 만들어진 API나 설정을 통해 주요 기능을 외부에서 제어하고자 할 때도 사용

# 추가로 알게 된 것

## OOAD(객체지향 분석과 설계)

- 소프트웨어를 개발하는 하나의 방법론
- 모든 소프트웨어 시스템의 주요 기본 요소를 사물을 가리키는 객체와 그 객체들을 하나의 집합으로 묶은 클래스로 구성하는 객체지향적인 분석과 설계 방법

[OOAD(Object Oriented Analysis and Design) 이란?](https://travel-diary.tistory.com/4)
