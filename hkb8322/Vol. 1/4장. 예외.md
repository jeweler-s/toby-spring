# 4.1 사라진 `SQLException`

## 초난감 예외처리 💦

1. `catch` 문 내 처리 로직 부재
2. `catch` 문 내 의미 없는 출력
3. 예외 무시
4. 메소드 선언부의 습관성 `throws`

⇒ 모든 예외는 적절히 복구 또는 작업 중단되어 분명하게 통보돼야 함

## 에러와 예외

### Error

- 시스템에 뭔가 비정상적인 상황이 발생한 경우
- 주로 JVM에서 발생
- 시스템 레벨에서 특별한 작업을 하는 게 아니라면 처리하지 않아도 됨

### Exception

- `java.lang.Exception`의 하위 클래스
- `RuntimeException` 상속 여부에 따라 체크 예외와 언체크 예외로 나뉨

## 예외의 종류

### 체크 예외

- `Exception` 상속, `RuntimeException` 상속 X
- 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성
    
    (그렇지 않을 경우 컴파일 오류 발생)
    
- 최근 자바 표준 스펙 API들은 예상 가능한 예외 상황을 다루는 예외를 체크 예외로 만들지 않음

### 언체크 예외

- `RuntimeException` 상속
- 명시적인 예외처리를 강제하지 않음
- 예상하지 못했던 예외 상황에서 발생하지 않으므로 `catch`나 `throws`를 사용하지 않아도 되도록 만들어짐

## 예외 처리 방법

### 예외 복구

- 예외 상황을 파악하고 문제를 해결하여 정상 상태로 돌려놓음
- 예외가 처리됐으면 기능적으로는 사용자에게 예외상황으로 비쳐도, 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행 필요

### 예외처리 회피

- 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던지는 것
- `throws`문 사용
- 콜백 오브젝트는 작업 중 발생하는 오류를 자신이 처리하지 않고 템플릿이 처리하도록 유도
    - 이런 상황이 아닐 때 회피하는 것은 무책임
- 의도가 분명할 때 사용 필요

### 예외 전환

- 발생한 예외를 적절한 예외로 전환하여 던짐
- 예외 상황에 대한 적절한 의미를 부여해주지 못한 경우 의미를 분명하게 하기 위해 사용
- 예외를 처리하기 쉽고 단순하게 만들기 위해서 포장하는 용도로도 사용
    - 주로 체크 예외를 언체크 예외로 바꾸는 경우 사용
- 사용 시 중첩 예외로 만들어 던지는 것이 좋음
- 복구 불가한 예외인 경우 런타임 예외로 포장하여 다른 계층의 메소드 작성 시 `throws` 선언이 들어가지 않도록 함

## 예외처리 전략

### **런타임 예외로 포장**

- 복구 불가하다면 런타임 예외로 포장해 던지는 것이 좋음
- 잡아서 처리할 수 있다면 런타임 예외로 만들자
- 예외 종류와 원인, 활용 방법에 대해 문서화를 상세히 해두어야 함

### 애플리케이션 예외 사용

1. **실행 결과에 따라 코드로 결과 리턴**
    - 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란 야기
    - 자칫하면 `if` 블록이 범벅될 가능성 존재
2. **커스텀 예외 사용**
    - 예외 상황에서는 비즈니스 의미가 담긴 예외를 던지도록 함
    - 개발자가 잊지 않고 처리할 수 있도록 의도적으로 체크 예외로 만듦

## `SQLException` 은 어떻게 됐나?

- 스프링의 `JdbcTemplate`은 아래와 같은 예외 처리 전략을 따름
    - 가능한 빨리 언체크/런타임 예외로 전환 !
- 콜백 내 발생하는 모든 `SQLException`을 런타임 예외인 `DataAccessException`으로 전환

# 4.2 예외 전환

## 예외 전환 목적

1. 불필요한 `catch/throws` 감소
2. 로우레벨의 예외를 보다 의미 있고 추상화된 예외로 전환

## JDBC의 한계

### 비표준 SQL

- 비표준 SQL이 포함된 DAO는 결국 특정 DB에 **종속적**이게 됨

### 에러 정보의 호환성

- 다양한 예외를 `SQLException` 하나로 퉁침
- 예외가 발생한 원인은 `SQLException`의 에러 코드를 참조해야 하지만 DB마다 다름

⇒ 결국 `SQLException`만으로 DB에 독립적인 유연한 코드를 작성하는 건 불가능

## DB 에러 코드 매핑을 통한 전환

- 스프링은 DB별 에러 코드를 분류하여 스프링이 정의한 예외 클래스와 매핑해놓은
    
    에러 코드 매핑 정보 테이블을 만들어두고 이를 이용
    
- 아직은 스프링의 에러 코드 매핑을 통한 `DataAccessException`을 사용하는 것이 이상적

## 데이터 액세스 예외 추상화와 `DataAccessException` 계층구조

- `DataAccessException` 은 의미가 같은 예외라면 데이터 액세스 기술의 종류와
    
    상관없이 일관된 예외가 발생하도록 함
    
- 데이터 액세스 기술에 독립적인 추상화된 예외 제공
- 일부 기술에서만 공통적으로 나타나는 예외를 포함해 데이터 액세스 기술에서
    
    발생 가능한 대부분의 예외를 계층구조로 분류
    

## `DataAccessException` 활용 시 주의사항

- 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주지만 근본적인 한계 존재
    - DB별로 예외 세분화 정도가 다르므로 세분화 정도에 따라 추상화 레벨 상이
- 학습 테스트를 통한 실제 예외 종류 확인 필요
- 기술의 종류에 상관 없이 동일한 예외를 얻고 싶을 경우
    - 커스텀 예외 정의
    - 예외 전환

### `DataAccessException` 전환 방법

1. DB 에러 코드 이용
2. `SQLExceptionTranslator` 인터페이스를 구현한 클래스 이용 (`SQLErorCodeSQLExceptionTranslator`)
    
    ```java
    SQLExcpetion sqlEx = (SQLException)ex.getRootCause();
    SQLExceptionTranslator set = new SqlErrorCodeSQLExceptionTranslator(this.dataSource);
    
    assertThat(set.translate(null, null, sqlEx), is(DuplicateKeyException.class));
    ```
